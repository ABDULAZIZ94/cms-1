#!/usr/bin/python
# -*- coding: utf-8 -*-

# Programming contest management system
# Copyright © 2010-2011 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright © 2010-2011 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright © 2010-2011 Matteo Boscariol <boscarim@hotmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Random utilities for web servers.

"""
import traceback

from functools import wraps

from cms.async.WebAsyncLibrary import rpc_callback
from cms.async import ServiceCoord
from cms.async.AsyncLibrary import logger
from cms.util.Cryptographics import decrypt_number

from tornado.web import HTTPError

def valid_phase_required(func):
    """Decorator that rejects requests outside the contest phase.

    """
    def newfunc(self, *args, **kwargs):
        if self.r_params["phase"] != 0:
            self.redirect("/")
        else:
            return func(self, *args, **kwargs)
    return newfunc


def catch_exceptions(func):
    def newfunc(self, *args, **kwargs):
        try:
            return func(self, *args, **kwargs)
        except HTTPError:
            # These errors are generated by the code (such as 404),
            # they're expected and tornado will take care of them.
            raise
        except Exception as e:
            logger.critical("Uncaught exception while processing "
                            "a request: %s" % traceback.format_exc())
            self.write("A critical error has occurred :-(")
            self.finish()
    return newfunc


def decrypt_arguments(func):
    """Decorator that decrypts all arguments.

    """
    def newfunc(self, *args, **kwargs):
        # We reply with Forbidden if the given ID cannot be decrypted.
        new_args = []
        for arg in args:
            try:
                new_args.append(decrypt_number(arg))
            except ValueError:
                logger.warning("User %s called with undecryptable argument." %
                               self.current_user.username)
                raise HTTPError(403)
        new_kwargs = {}
        for k in kwargs:
            try:
                new_kwargs[k] = decrypt_number(kwargs[k])
            except ValueError:
                logger.warning("User %s called with undecryptable argument." %
                               self.current_user.username)
                raise HTTPError(403)
        return func(self, *new_args, **new_kwargs)
    return newfunc


def file_handler_gen(BaseClass):
    """This generates an extension of the BaseHandler that allows us
    to send files to the user. This *Gen is needed because the code in
    the class FileHandler is exactly the same (in AWS and CWS) but
    they inherits from different BaseHandler.

    BaseClass (class): the BaseHandler of our server.
    returns (class): a FileHandler extending BaseClass.

    """
    class FileHandler(BaseClass):
        """Base class for handlers that need to serve a file to the user.

        """
        def fetch(self, digest, content_type, filename):
            """Sends the RPC to the FS.

            """
            self.application.service.FC.get_file_to_string(
                callback=self._fetch_callback,
                plus=[content_type, filename],
                digest=digest)

        @rpc_callback
        def _fetch_callback(self, caller, data, plus, error=None):
            """This is the callback for the RPC method called from a web
            page, that just collects the response.

            """
            if data is None:
                self.finish()
                return
            (content_type, filename) = plus

            self.set_header("Content-Type", content_type)
            self.set_header("Content-Disposition",
                            "attachment; filename=\"%s\"" % filename)
            self.data = data
            self.application.service.add_timeout(self._fetch_write_chunk, None, 0.01)

        def _fetch_write_chunk(self, chunk_size=8192):
            if len(self.data) > chunk_size:
                self.write(self.data[:chunk_size])
                self.data = self.data[chunk_size:]
                return True
            else:
                self.write(self.data)
                self.finish()
                return False

    return FileHandler
