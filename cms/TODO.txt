*** BLOCKERS



** High priority

* Test that all languages (particularly Pascal) work correctly.



** Medium priority

* Remove all sync'ed RPC (e.g. there are some in Worker).



** Low priority

* Make sure that the first operation triggered in async is reconnect.

* Always refer to tasks, testcases and such by id instead of num (as
  it is for everything else).

* Correct the commit by root, and move to github.





*** OTHERS



** Database

* LOW: Define appropriate UNIQUE indexes in the database.

* LOW: Task and Testcase are sometimes referenced by num, instead of
  properly using IDs.

* LOW: It may be interesting to keep in the Contest not only the last
  scoring snapshot, but a snapshot for each moments in which the
  scorings change.

* HIGH: Ensure that CWS in particular, but also everything else, does not
  rely on the particular value of the id of the database
  objects. E.g., we may assume that everything work as expected even
  if we scramble all ids in the db (keeping the relations correct, of
  course). This actually happens when we call ContestExporter and
  ContestImporter.



** Worker

* LOW: Should be able to work with 32 bits programs even when running in
  64 bits mode.
  - This actually appears to be quite complicated: it is probably
    easier and more secure to just ask that everything must be made
    with the same number of bits; at the moment it is assumed that
    everything works at 32 bits. I have a 64 bits system and keep
    the Worker inside a 32 bits chroot.



** EvaluationServer

* HIGH: Check that there are no concurrence issues, particularly in scoring
  routines.

* HIGH: Really, really slow to add the already evaluated submissions
  at start. The problem is *not* related to unnecessary
  updates. Indeed, most of the time is spent when we first mention
  contest.rankingview.scores. Is this a sqlite issue?

* MED: When starting, check that the workers are not doing anything and
  possibly stop them / wait for them to be finished.



** Task types

* HIGH: implement communication task types.

* MED: output only tasks should accept partial submissions.

* LOW: ease the creation of new task types.



** ContestWebServer

* HIGH: It _MUST_ be able to work correctly (storing submitted data)
  even if no services other than the database and FileStorage are
  available; if database or File Storage are missing it _MUST_ behave
  nicely anyway, informing the user to seek assistance and without
  crashing.

* MED: auto update the "compiling" message after a submission - really
  tedious and traffic-generating to let the user refresh.

* LOW: ability to switch to submission form to send tarred submissions?

* LOW: Some idea to improve the Web interface:
  - Ability to backup files.
  - Ability to talk with Emacs psychologist, in case of a particularly
    difficult contest.
  - Put an Italian flag somewhere.
  - I think that the AGPL license also asks us to put appropriate
    copyright notices in the Web interface.



** AdminWebServer

* MED: see CWS for auto updating submissions' statuses.

* LOW: show resource usage of all the boxes.



** YamlImporter

* LOW: Provide facilities to translate the task's statement.

* LOW: Provide an environment to build tasks better than make_Makefile and
  friends.



** Contest{Exporter,Importer}

* LOW: Use consistenly names to export Tasks, as in the cases of Users.



** File{Storage,Cacher}

* HIGH: Duly document callbacks in FileCacher.

* MED: Don't load the whole files when transferring them, you uselessly eat
  a huge lot of memory.

* MED: The current implementation is very confused and probably quite
  prone to errors; try to make it a bit simpler.

* LOW: Add support to optionally check file digests when trasferring them, both
  on client and on server side. Moreover, add an API call to ask the
  server to verify some file's digest.




** AsyncLibrary

* HIGH: Duly document the make_sync decorator.

* HIGH: Understand which call we need when a long running function has time
  to spare (_step? asyncore.loop?), for example as in make_sync
  implementation.
  - Actually, synchronous interfaces are a pain anyway. We should just
    not use them in the main system (importers, exporters and other things
    are fine, since they're not critical and run human-assisted).

* MED: Decide on bind_obj=None behaviour and about keeping bind_obj.

* MED: Add a method to do a one-time deferred call (like add_timeout(),
  but just one time).
  - Already done, but it has many shortcomings and completely breaks
    synchronous interfaces.

* MED: Fix sync default.



** setup.py

* MED: Understand how to avoid the problem of files create in cmsuser
  directories having uid of calling user instead of cmsuser. Good
  solution should be of having cms* to be run as cmsuser, but suid
  seems hard with scripts. Is there a +something option for
  directories to enable this behaviour?

